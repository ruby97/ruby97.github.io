---
layout: post
title: Mysql锁问题
date: 2017-04-14 12:00:00.000000000 +09:00
---

## Mysql锁概述
---
+ 表级锁
+ 行级锁
+ 页面锁

## MyISAM锁问题
MyISAM只支持表锁

### 查询表级锁争用情况

``show status like 'table%';``

如果Table_locks_waited较高，说明表级锁争用严重

Mysql表级锁有两种模式
+ 表共享读锁
对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求
+ 表独占写锁
对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作

### 并发插入
MyISAM有一个系统变量concurrent_insert:
+ 0: 不允许并发插入
+ 1: 如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置
+ 2: 无论MyISAM表中有没有空洞，都允许在表尾并发插入记录

MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。
** 写请求后到，写锁也会插到读锁请求之前 **

### MyISAM的锁调度
可以通过设置来调节MyISAM调度行为：
+ 制定启动参数low-priority-updates,使MyISAM给予读请求以优先的权利
+ SET LOW_PRIORITY_UPDATES = 1使更新请求的优先级降低
+ 指定INSERT,UPDATE,DELETE语句的LOW_PRIORITY属性


## InnoDb锁问题
---
支持事务，采用了行级锁

并发事务处理带来的问题：
+ 更新丢失
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新
+ 脏读
一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态
+ 不可重复读
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了
+ 幻读
一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据

隔离级别及允许出现的副作用：
| 隔离级别 | 读数据一致性 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- | --- |
| 未提交读 | 最低级别 | 是 | 是 | 是 |
| 已提交读 | 语句级 | 否 | 是 | 是 |
| 可重复读 | 事务级 | 否 | 否 | 是 |
| 可序列化 | 最高级别，事务级 | 否 | 否 | 否 |

### InndDB行锁争用情况
``show status like 'innodb_row_lock%';``
如果InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，说明锁争用比较严重

### InnoDB行锁模式及加锁方法
2种行锁
+ 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁
+ 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（**表锁**）
+ 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁
+ 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁

意向锁是InnoDB自动加的，不需用户干预
对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)
对于普通SELECT语句，InnoDB不会加任何锁

+ 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
+ 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE

用SELECT ... IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT... FOR UPDATE方式获得排他锁

### InnoDB行锁实现方式
InnoDB行锁是通过给索引上的**索引项**加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB才使用行级锁**，否则，InnoDB将使用表锁

由于MySQL的行锁是针对**索引**加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的

当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁

即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁

**检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引**

### 间隙锁
当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）

InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁

### 恢复和复制的需要，对InnoDB锁机制的影响

对于“insert  into target_tab select * from source_tab where ...”和“create  table new_tab ...select ... From  source_tab where ...(CTAS)”这种SQL语句，用户并没有对source_tab做任何更新操作，但MySQL对这种SQL语句做了特别处理

INSERT...SELECT...和CREATE TABLE...SELECT...语句，可能会阻止对源表的并发更新，造成对源表锁的等待。如果查询比较复杂的话，会造成严重的性能问题，我们在应用中应尽量避免使用

### 什么时候使用表锁
对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由
在个别特殊事务中，也可以考虑使用表级锁:
+ 事务需要更新大部分或者全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度
+ 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销

在InnoDB下，使用表锁要注意以下两点
+ 仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁
+ 用LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁

### 关于死锁
发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决
在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生

几种避免死锁的常用方法：
+ 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会
+ 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能
+ 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁

如果出现死锁，可以用``SHOW INNODB STATUS``命令来确定最后一个死锁产生的原因

