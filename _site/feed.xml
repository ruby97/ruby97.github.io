<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nino Dong</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 14 Apr 2017 15:53:19 +0800</pubDate>
    <lastBuildDate>Fri, 14 Apr 2017 15:53:19 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Mysql锁问题</title>
        <description>&lt;h2 id=&quot;mysql锁概述&quot;&gt;Mysql锁概述&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;表级锁&lt;/li&gt;
  &lt;li&gt;行级锁&lt;/li&gt;
  &lt;li&gt;页面锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;myisam锁问题&quot;&gt;MyISAM锁问题&lt;/h2&gt;
&lt;p&gt;MyISAM只支持表锁&lt;/p&gt;

&lt;h3 id=&quot;查询表级锁争用情况&quot;&gt;查询表级锁争用情况&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;show status like 'table%';&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果Table_locks_waited较高，说明表级锁争用严重&lt;/p&gt;

&lt;p&gt;Mysql表级锁有两种模式&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;表共享读锁
对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求&lt;/li&gt;
  &lt;li&gt;表独占写锁
对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;并发插入&quot;&gt;并发插入&lt;/h3&gt;
&lt;p&gt;MyISAM有一个系统变量concurrent_insert:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;0: 不允许并发插入&lt;/li&gt;
  &lt;li&gt;1: 如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置&lt;/li&gt;
  &lt;li&gt;2: 无论MyISAM表中有没有空洞，都允许在表尾并发插入记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MyISAM存储引擎的读锁和写锁是互斥的，读写操作是串行的。
** 写请求后到，写锁也会插到读锁请求之前 **&lt;/p&gt;

&lt;h3 id=&quot;myisam的锁调度&quot;&gt;MyISAM的锁调度&lt;/h3&gt;
&lt;p&gt;可以通过设置来调节MyISAM调度行为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;制定启动参数low-priority-updates,使MyISAM给予读请求以优先的权利&lt;/li&gt;
  &lt;li&gt;SET LOW_PRIORITY_UPDATES = 1使更新请求的优先级降低&lt;/li&gt;
  &lt;li&gt;指定INSERT,UPDATE,DELETE语句的LOW_PRIORITY属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;innodb锁问题&quot;&gt;InnoDb锁问题&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;支持事务，采用了行级锁&lt;/p&gt;

&lt;p&gt;并发事务处理带来的问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;更新丢失
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新&lt;/li&gt;
  &lt;li&gt;脏读
一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态&lt;/li&gt;
  &lt;li&gt;不可重复读
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了&lt;/li&gt;
  &lt;li&gt;幻读
一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;隔离级别及允许出现的副作用：
| 隔离级别 | 读数据一致性 | 脏读 | 不可重复读 | 幻读 |
| — | — | — | — | — |
| 未提交读 | 最低级别 | 是 | 是 | 是 |
| 已提交读 | 语句级 | 否 | 是 | 是 |
| 可重复读 | 事务级 | 否 | 否 | 是 |
| 可序列化 | 最高级别，事务级 | 否 | 否 | 否 |&lt;/p&gt;

&lt;h3 id=&quot;innddb行锁争用情况&quot;&gt;InndDB行锁争用情况&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;show status like 'innodb_row_lock%';&lt;/code&gt;
如果InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，说明锁争用比较严重&lt;/p&gt;

&lt;h3 id=&quot;innodb行锁模式及加锁方法&quot;&gt;InnoDB行锁模式及加锁方法&lt;/h3&gt;
&lt;p&gt;2种行锁&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁&lt;/li&gt;
  &lt;li&gt;排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（&lt;strong&gt;表锁&lt;/strong&gt;）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁&lt;/li&gt;
  &lt;li&gt;意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;意向锁是InnoDB自动加的，不需用户干预
对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)
对于普通SELECT语句，InnoDB不会加任何锁&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE&lt;/li&gt;
  &lt;li&gt;排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁&lt;/p&gt;

&lt;h3 id=&quot;innodb行锁实现方式&quot;&gt;InnoDB行锁实现方式&lt;/h3&gt;
&lt;p&gt;InnoDB行锁是通过给索引上的&lt;strong&gt;索引项&lt;/strong&gt;加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：&lt;strong&gt;只有通过索引条件检索数据，InnoDB才使用行级锁&lt;/strong&gt;，否则，InnoDB将使用表锁&lt;/p&gt;

&lt;p&gt;由于MySQL的行锁是针对&lt;strong&gt;索引&lt;/strong&gt;加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的&lt;/p&gt;

&lt;p&gt;当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁&lt;/p&gt;

&lt;p&gt;即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;间隙锁&quot;&gt;间隙锁&lt;/h3&gt;
&lt;p&gt;当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）&lt;/p&gt;

&lt;p&gt;InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁&lt;/p&gt;

&lt;h3 id=&quot;恢复和复制的需要对innodb锁机制的影响&quot;&gt;恢复和复制的需要，对InnoDB锁机制的影响&lt;/h3&gt;

&lt;p&gt;对于“insert  into target_tab select * from source_tab where …”和“create  table new_tab …select … From  source_tab where …(CTAS)”这种SQL语句，用户并没有对source_tab做任何更新操作，但MySQL对这种SQL语句做了特别处理&lt;/p&gt;

&lt;p&gt;INSERT…SELECT…和CREATE TABLE…SELECT…语句，可能会阻止对源表的并发更新，造成对源表锁的等待。如果查询比较复杂的话，会造成严重的性能问题，我们在应用中应尽量避免使用&lt;/p&gt;

&lt;h3 id=&quot;什么时候使用表锁&quot;&gt;什么时候使用表锁&lt;/h3&gt;
&lt;p&gt;对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由
在个别特殊事务中，也可以考虑使用表级锁:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;事务需要更新大部分或者全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度&lt;/li&gt;
  &lt;li&gt;事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在InnoDB下，使用表锁要注意以下两点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁&lt;/li&gt;
  &lt;li&gt;用LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关于死锁&quot;&gt;关于死锁&lt;/h3&gt;
&lt;p&gt;发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数innodb_lock_wait_timeout来解决
在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生&lt;/p&gt;

&lt;p&gt;几种避免死锁的常用方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会&lt;/li&gt;
  &lt;li&gt;在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能&lt;/li&gt;
  &lt;li&gt;在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果出现死锁，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;SHOW INNODB STATUS&lt;/code&gt;命令来确定最后一个死锁产生的原因&lt;/p&gt;

</description>
        <pubDate>Fri, 14 Apr 2017 11:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/Mysql%E9%94%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/Mysql%E9%94%81/</guid>
        
        
      </item>
    
  </channel>
</rss>
